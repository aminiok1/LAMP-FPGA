import os
import numpy as np
import scipy.io as sio
import tensorflow as tf
tf.compat.v1.logging.set_verbosity(tf.compat.v1.logging.ERROR)
import keras
from keras.layers import Dense, Conv2D, InputLayer, Flatten, MaxPool2D
import tensorflow.contrib.decent_q
from MPTimeSeriesGenerator import MPTimeseriesGenerator
from sklearn.metrics import mean_squared_error

# returns the mean absolute percentage error
def mean_absolute_percentage_error(y_true, y_pred): 
  
    return np.mean(np.abs((y_true - y_pred) / y_true)) * 100

# create a new keras session to load the frozen binary model
tf_session = keras.backend.get_session()
input_graph_def = tf_session.graph.as_graph_def()
tf.reset_default_graph()

# Load the quantized model generated by Vitis-AI quantizer
with tf.gfile.GFile('quantized/quantize_eval_model.pb', "rb") as f:
    graph = tf.GraphDef()
    graph.ParseFromString(f.read())

tf.import_graph_def(graph,name = '')

# set the input tensor
input_data = tf.get_default_graph().get_tensor_by_name('input_1'+':0')

# set the output tensor
labels = tf.placeholder(tf.float32)
logits = tf.get_default_graph().get_tensor_by_name(
        'reshape_1/Reshape'+':0')

nn_output = tf.argmax(logits, 1)

correct_prediction = tf.metrics.accuracy(logits[:, 0, :], labels)
accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))

# Load the input dataset 
all_data = sio.loadmat('insect_no_classification.mat')
mp_val = np.array(all_data['mp_val'])
ts_val = np.array(all_data['ts_val'])

# Input time series parameter
sample_rate = 20
lookbehind_seconds = 0
lookahead_seconds = 0
subsequence_stride = 256
lookbehind = sample_rate * lookbehind_seconds
num_outputs = 256
lookahead = sample_rate * lookahead_seconds
forward_sequences = lookahead + num_outputs
subsequences_per_input = lookbehind + num_outputs + lookahead

# Channel stride is the stride between extracted subsequences in the input
channel_stride = 8
# Number of time series dimensions to consider
n_input_series = 1
subsequences_per_input = subsequences_per_input // channel_stride

high_weight = 1
low_thresh = -1
high_thresh = 1

# Generate the input time series with the particular window size
valid_gen = MPTimeseriesGenerator(ts_val, mp_val, num_input_timeseries=1, internal_stride=8, num_outputs=256,lookahead=forward_sequences, lookbehind=lookbehind, important_upper_threshold=high_thresh, important_lower_threshold=low_thresh, important_weight=high_weight, length=256, mp_window=256, stride=num_outputs, batch_size=32)

for i in range(len(valid_gen):
    a = valid_gen[i]
    x_test, y_test = a
    y_test = y_test[:, 0, :]
    

    with tf.Session() as sess:
	
	    # run the quantized model and get the output
        sess.run(tf.global_variables_initializer())
        sess.run(tf.initializers.local_variables())
        
        acc = accuracy.eval(feed_dict={input_data: x_test, labels: y_test})
        
        model_output = logits.eval(feed_dict={input_data: x_test, labels: y_test})[:, 0, :] 
     
	    # print accuracy metrics
 	    print(mean_squared_error(model_output, y_test))
        print(mean_absolute_percentage_error(model_output, y_test))
